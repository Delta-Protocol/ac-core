package us.wallet;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.Socket;
import java.security.SecureRandom;
import org.spongycastle.math.ec.ECPoint;

public class Wallet {

    private BigInteger priv;
    private ECPoint pub;
    public String my_address;

    public class tx_make_p2pkh_input {
        public static final int sigcode_all=0;
        public static final int sigcode_none=1;
        public static final int sigcode_this=2;

        public tx_make_p2pkh_input(String rcpt_addr0, int amount0, int fee0, int sigcode_inputs0, int sigcode_outputs0, boolean sendover0) {
            rcpt_addr=rcpt_addr0;
            amount=amount0;
            fee=fee0;
            if (amount<1) amount=0;
            if (fee<1) fee=0;
            sigcode_inputs=sigcode_inputs0;
            sigcode_outputs=sigcode_outputs0;
            sendover=sendover0;
        }

        String rcpt_addr;
        int amount;
        int fee;
        int sigcode_inputs;
        int sigcode_outputs;
        boolean sendover;

        boolean check() {
            return fee>0 && amount>0 && !rcpt_addr.isEmpty();
        }

        String to_string() {
            return rcpt_addr+" "+amount+" "+fee+" "+sigcode_all+" "+sigcode_all+" "+(sendover?"1":"0");
        }
    }


    private File homeDir;

    public Wallet(File homedir) throws IOException {
	homeDir=homedir;
        setup_keys();
        setup_addr();
        setup_walletd_host();
        setup_walletd_port();
    }



    public FileOutputStream getOutputStream(String filename) throws IOException {
	//override. i.e. in Android: return ctx.openFileOutput(filename, Context.MODE_PRIVATE);
	return new FileOutputStream(filename);
    }

    void setup_keys() throws IOException {
        String filename = "k";
        String fileContents;
        File file = new File(homeDir,filename);
        if(!file.exists()) {
            file.getParentFile().mkdirs();
    //        try {
                file.createNewFile();
      //      }
        //    catch(Exception e) {
          //  }
            //           log+=";new file";
//            if (!file.mkdirs()) {
            //              //Log.e(LOG_TAG, "Directory not created");
            //            log+=";Directory not created";
            //      }

            fileContents = EllipticCryptography.getInstance().generatePrivateKey().toString();
            //log+=";"+fileContents.length();
            FileOutputStream outputStream;
//            outputStream = ctx.openFileOutput(filename, Context.MODE_PRIVATE);
            outputStream = getOutputStream(filename);
            outputStream.write(fileContents.getBytes());
            outputStream.write('\n');
            outputStream.close();
        }
        else {
            fileContents = getStringFromFile(file);
        }

        try {
            priv = new BigInteger(fileContents);
        }
        catch(Exception e){
           // Log.e("Wallet",e.getMessage());
            throw new IOException("Cannotmake priv key");
        }
        if(priv==null){
            throw new IOException("priv key is null");
            //Log.d("Wallet", "Private key was not successfully retrieved");
        }
        pub = EllipticCryptography.getInstance().publicPointFromPrivate(priv);
    }

    public static final short protocol_suffix = 0;


//---------------------------------------------------------------------generated by make, do not edit
//content of file: api/apitool_generated__protocol_gov_id_java
//------------------generated by apitool- do not edit
// gov_id - master file: us/apitool/data/gov_id
    public static final short protocol_gov_id_base = 200;
    public static final short protocol_gov_id_request = ((protocol_gov_id_base+0)<<2)+protocol_suffix;
    public static final short protocol_gov_id_peer_challenge = ((protocol_gov_id_base+1)<<2)+protocol_suffix;
    public static final short protocol_gov_id_challenge_response = ((protocol_gov_id_base+2)<<2)+protocol_suffix;
    public static final short protocol_gov_id_peer_status = ((protocol_gov_id_base+3)<<2)+protocol_suffix;
//-/----------------generated by apitool- do not edit

//content of file: api/apitool_generated__protocol_wallet-daemon_java
//------------------generated by apitool- do not edit
// wallet - master file: us/apitool/data/wallet
    public static final short protocol_wallet_base = 0;
    public static final short protocol_wallet_balance = protocol_wallet_base+0;
    public static final short protocol_wallet_list = protocol_wallet_base+2;
    public static final short protocol_wallet_new_address = protocol_wallet_base+4;
    public static final short protocol_wallet_add_address = protocol_wallet_base+6;
    public static final short protocol_wallet_transfer = protocol_wallet_base+8;
    public static final short protocol_wallet_tx_make_p2pkh = protocol_wallet_base+10;
    public static final short protocol_wallet_tx_sign = protocol_wallet_base+12;
    public static final short protocol_wallet_tx_send = protocol_wallet_base+14;
    public static final short protocol_wallet_tx_decode = protocol_wallet_base+16;
    public static final short protocol_wallet_tx_check = protocol_wallet_base+18;
    public static final short protocol_wallet_ping = protocol_wallet_base+20;
// pairing - master file: us/apitool/data/pairing
    public static final short protocol_pairing_base = 100;
    public static final short protocol_pairing_pair = protocol_pairing_base+0;
    public static final short protocol_pairing_unpair = protocol_pairing_base+2;
    public static final short protocol_pairing_list_devices = protocol_pairing_base+4;
//-/----------------generated by apitool- do not edit
//-/-------------------------------------------------------------------generated by make, do not edit

    void setup_addr() throws IOException  {
        String filename = "a";
        File file = new File(homeDir,filename);
        if(!file.exists()) {
            renew_address();
        }
        my_address=getStringFromFile(file);
    }

    void setup_walletd_host() throws IOException  {
        String filename = "n";
        File file = new File(homeDir,filename);
        if(file.exists()) {
	        walletdAddress=getStringFromFile(file);
//            throw new IOException("Walletd-endpoint file does not exist. "+homeDir+"/n");
        }
	else {
	        walletdAddress="127.0.0.1";
	}
    }
    void setup_walletd_port() throws IOException  {
        walletdPort=16673;
        String filename = "p";
        File file = new File(homeDir,filename);
        if(file.exists()) {
		try {
		        walletdPort=Integer.parseInt(getStringFromFile(file));
		}
		catch(NumberFormatException E) {
		}
        }
    }

    public void set_walletd_host(String addr) throws IOException {
        String filename = "n";
        File file = new File(homeDir,filename);
        file.getParentFile().mkdirs();
        file.createNewFile();
        FileOutputStream outputStream;
        outputStream = getOutputStream(filename);
        outputStream.write(addr.getBytes());
        outputStream.write('\n');
        outputStream.close();
        walletdAddress=getStringFromFile(file);
    }

    public boolean set_walletd_port(int port) throws IOException {
        String filename = "p";
        File file = new File(homeDir,filename);
        file.getParentFile().mkdirs();
        file.createNewFile();
        FileOutputStream outputStream;
        outputStream = getOutputStream(filename);
        outputStream.write(Integer.toString(port).getBytes());
        outputStream.write('\n');
        outputStream.close();
	try {
        	walletdPort=Integer.parseInt(getStringFromFile(file));
		return true;
	}
	catch(NumberFormatException e) {
		return false;
	}
    }

    public String getStringFromFile (File fl) {
        try {
            FileInputStream fin = new FileInputStream(fl);
            String ret = convertStreamToString(fin);
            fin.close();
            return ret;
        }
        catch(Exception e) {
            return "";
        }
    }

    public String convertStreamToString(InputStream is) throws Exception { //1 line
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));

        StringBuilder sb = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) {
            sb.append(line);
            break;
        }
        reader.close();
        return sb.toString();
    }

    private String walletdAddress="";
    private int walletdPort=16673;

    public String walletd_host() {
        return walletdAddress;
    }

    public int walletd_port() {
        return walletdPort;
    }

    public String pay(int amount, int fee, String rcpt_address) {
        tx_make_p2pkh_input i=new tx_make_p2pkh_input(rcpt_address,amount,fee,tx_make_p2pkh_input.sigcode_all,tx_make_p2pkh_input.sigcode_all,true);
        if (!i.check()) return "Error: Invalid input data";

        String args=i.to_string();
        //Log.d("Wallet","Pay order "+args);

        return ask(protocol_wallet_tx_make_p2pkh,args);
    }

    private Datagram curd=null;

    private Datagram complete_datagram(Socket sock) {
        if (curd==null) curd=new Datagram();
        if (!curd.recv(sock)) {
            curd=null;
            return null;
        }
        if (curd.completed()) {
            Datagram t=curd;
            curd=null;
            return t;
        }
        return curd;
    }

    enum stage_t {
            anonymous,
            verified,
            verified_fail,
            num_stages
    };

public class pair<T, U> {
    public T first;
    public U second;

    public pair(T f, U s) {
        this.first=f;
        this.second=s;
     }
 }



/*
void process_peer_challenge(Datagram d) {
    String data=d.parse_string();

    string hello_msg;
    pubkey_t peer_pubk;
    string peer_signature_der_b58;

    String[] fields = data.split("\\s+");
    if (fields.lenfth!=3) {
        stage_peer=verified_fail;
        return;
    }

    string peer_pubk=fields[0];
    string peer_signature_der_b58=fields[1];
    string hello_msg=fields[2];

    if (!peer_pubk.valid) {
        stage_peer=verified_fail;
    }
    else if (likely(crypto::ec::instance.verify(peer_pubk,msg,peer_signature_der_b58))) {
        stage_peer=verified;
        pubkey=peer_pubk;
//cout << "ID: peer_pubk ok" << endl;
    }
    else {
        stage_peer=verified_fail;
//cout << "ID: peer_pubk and signature verif fail" << endl;
        //TODO sleep random time before answering peer , timing attack
    }
    msg.clear();

    assert(mykeys.pub.valid);

//cout << "ID signing with priv " << mykeys.priv << " - " << mykeys.pub << endl;

    string signature_der_b58=crypto::ec::instance.sign_encode(mykeys.priv,hello_msg);
    ostringstream os;
    os << mykeys.pub << ' ' << signature_der_b58 << ' ' << stage_peer;
//cout << "ID sending id_challenge_response " << os.str() << endl;
    send(new datagram(protocol::id_challenge_response,os.str()));

}
*/


String msg;

void auth_initiate_dialogue(Socket s) {
    msg=get_random_message();
    new Datagram(protocol_gov_id_request,msg).send(s);
}

String get_random_message() {
return "DUMMY-MSG";  //uncomment for deterministic debugging
/*
    vector<unsigned char> v;
    v.resize(20);
    ifstream f("/dev/urandom");
    f.read(reinterpret_cast<char*>(&v[0]),v.size());
    return to_string(v);
*/
}


/*
    public pair<String,Datagram> recv(Socket s) {
        pair<String,Datagram> r=new pair<String,Datagram>(new String(),new Datagram());
        while(true) {
            if (!r.second.recv(s)) {
                s.close(); //disconnect();
                break;
            }
            if (r.second.completed()) break;
        }
        return r;
    }
*/

public boolean process_work(Datagram d) {
/*
    switch(d.service) {
        //case gov_id_request: process_request(d); break;
        case gov_id_peer_challenge: process_peer_challenge(d); break;
        case gov_id_challenge_response: process_challenge_response(d); break;
        case gov_id_peer_status: process_peer_status(d); break;
    default: return false;
    }
*/
    return true;
}

/*
    public String run_auth_responder(Socket s) {
        stage_t stage_peer=stage_t.anonymous;
        stage_t stage_me=stage_t.anonymous;

     while(true) {
        if (stage_peer==stage_t.verified || stage_peer==stage_t.verified_fail) {
        if (stage_me==stage_t.verified || stage_me==stage_t.verified_fail) {
            break;
        }
        }

        pair<String,Datagram> r=recv();
        if (!r.first.isEmpty()) {
            return "Error. Peer not responding";
        }
        if (process_work(r.second)) {
                continue;
        }

        return "Error. Unrecognized datagram arrived";
    }
    return stage_peer==stage_t.verified?"":"Error. Peer failed to demonstrate identity";

    }
*/

    public synchronized Datagram send_recv(Datagram d) {
        try {
            Socket s = new Socket(walletd_host(), walletd_port());
/*
            if (!run_auth_responder(s)) {
                return null;
            }
*/
            d.send(s);
            Datagram r=null;
            while (true) {
                r=complete_datagram(s);
                if (r==null) break;
                if (r.completed()) break;
            }
            s.close();
            return r;
        } catch (IOException e) {
        }

        return null;
    }

    String ask(short service, String args) {
        Datagram d=new Datagram(service,args);
        Datagram r=send_recv(d);
        if (r==null) return "?";
        String st;
        st = r.parse_string();
        //Log.d("Wallet","ans "+st);
        return st.trim();
    }

    public boolean isAddressValid(String addr) {
        try {
            byte[] decoded=Base58.decode(addr);
            return decoded.length>0;
        }
        catch(Base58.AddressFormatException e) {
            return false;
        }
    }

    public boolean renew_address() throws IOException {
        String addr=new_address();
        if (!isAddressValid(addr)) {
            return false;
        }
        my_address=addr;

        String filename = "a";
        File file = new File(homeDir,filename);
        file.getParentFile().mkdirs();
        file.createNewFile();
        FileOutputStream outputStream;
        outputStream = getOutputStream(filename);
        outputStream.write(my_address.getBytes());
        outputStream.write('\n');
        outputStream.close();
        return true;
    }

    public String balance(boolean detailed) {
        return ask(protocol_wallet_balance,detailed?"1":"0");
    }

    public String new_address() {
        return ask(protocol_wallet_new_address,"");
    }

    public String ping() {
        return ask(protocol_wallet_ping,"");
    }

    public String pair() {
        return ask(protocol_pairing_pair,"");
    }


}
